\input texinfo
@setfilename unixsignal.info
@include version.texi
@settitle unixsignal @value{VERSION}
@syncodeindex pg cp

@copying
This manual is for libunixsignal (version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2009 Dmitry Goncharov.
Distributed under the BSD license.

@ignore
@quotation
@end quotation
@end ignore
@end copying

@dircategory ????
@direntry
* unixsignal: unixsignal.
@end direntry

@titlepage
@title unixsignal
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Dmitry Goncharov (@email{dgoncharov@@users.sourceforge.net})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top unixsignal

This manual is for libunixsignal (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Introduction::
* Header <unixsignal/signalfd.hpp>::
* Header <unixsignal/signal_handler.hpp>::
@end menu


@node Introduction
@chapter Introduction
This library lets you associate a unix signal with a file descriptor
and have the file descriptor ready for reading whenever the associated unix signal arrives.
This lets multiplex unix signals just like file descriptors.
This library also extends boost::asio with the ability to invoke a handler whenever a unix signal arrives.

Motivation for this library was the need to pass user data to a signal handler.
Another factor was the need to invoke syscalls which are not async-signal-safe from a signal handler. 

The library consists of two header files unixsignal/signalfd.hpp and unixsignal/signal_handler.hpp.

The library can be used to handle asynchronous unix signals such as SIGINT or SIGHUP.
It is not recommended to use the library to handle synchronous unix signals such as SIGFPE, SIGILL, SIGSEGV, or SIGBUS unless the signal was generated by the kill() function, the sigqueue() function, or the raise() function.

@node Header <unixsignal/signalfd.hpp>
@chapter Header <unixsignal/signalfd.hpp>

@b{Synopsis}


@example
namespace unixsignal @{

template <int Signo>
class signalfd
@{
public:
    signalfd();
    ~signalfd();

    int fd() const;

private:
    signalfd(signalfd<Signo> const&);
    signalfd<Signo>& operator=(signalfd<Signo> const&);
@};

@}
@end example


@b{Description}


@example
Class template signalfd creates a file descriptor and associates it with a signal specified by the template parameter Signo.
This file descriptor becomes ready for reading each time the associated signal arrives.
Users can use select/poll multiplexing to wait for this file descriptor to become reading for reading.
Users should read sizeof(char) bytes from this file descriptor after it became ready for reading.
If the user fails to read sizeof(char) bytes from the file descriptor after it became ready for reading
the descriptor effectively remains in the ready for reading state.
In this case select/poll multiplexing mechanism will immediately return this file descriptor as ready for reading.
Users must not close this file descriptor. 

signalfd is neither copyable nor assignable.

signalfd uses the following syscalls pipe(), sigaction(), close(), write() and is portable as long as these syscalls are portable.

@end example

signalfd()

@example
Effects: Creates an instance of signalfd. Sets the disposition of the specified signal Signo to a pointer to a function.
         Creates a file descritor and assiciated it with the specified signal.
Postconditions: this->fd() return the file descriptor associated with the signal.
Throws: boost::system_error if one of the syscalls fails. If an exception is thrown the signal disposition remains intact.
@end example

~signalfd()

@example
Effects: Restores the original signal disposition. Closes the file descriptor.
Throws: Does not throw.
Postconditions: The original signal disposition is restored.
@end example

int fd() const

@example
Returns: The file descriptor associated with the signal.
Throws: Does not throw.
@end example


@b{Example}


@example
#include <sys/select.h>
#include <signal.h>

#include <cstdio>
#include <cstdlib>
#include <cerrno>
#include <cstring>

#include <iostream>
#include <iomanip>
#include <string>

#include <unixsignal/signalfd.hpp>

using std::cout;
using std::cin;
using std::endl;
using std::cerr;
using std::flush;

int main(int, char const* [])
@{
    unixsignal::signalfd<SIGINT> sigint;
    int const intfd = sigint.fd();

    unixsignal::signalfd<SIGTERM> sigterm;
    int const termfd = sigterm.fd();

    cout << "Type to watch stdin activity. Send signals to watch the program react. Use ^D to exit" << endl << "# " << flush;
    while (std::cin)
    @{
        fd_set rfds;
        FD_ZERO(&rfds);
        FD_SET(STDIN_FILENO, &rfds);
        FD_SET(intfd, &rfds);
        FD_SET(termfd, &rfds);

        int const s = select(std::max(intfd, termfd) + 1, &rfds, 0, 0, 0);
        if (s < 0)
        @{
            if (EINTR != errno)
                cerr << "select(): " << strerror(errno) << endl;
            continue;
        @}
        if (FD_ISSET(0, &rfds))
        @{
            std::string s;
            std::getline(cin, s);
            cout << "activity on stdin: " << s << endl;
        @}
        else if (FD_ISSET(intfd, &rfds))
        @{
            cout << "sigint received" << endl;
            char c;
            int const s = read(intfd, &c, sizeof c);
            if (s < 0)
                cerr << "Cannot read from intfd: read(): " << strerror(errno) << endl;
        @}
        else if (FD_ISSET(termfd, &rfds))
        @{
            cout << "sigterm received" << endl;
            char c;
            int const s = read(termfd, &c, sizeof c);
            if (s < 0)
                cerr << "Cannot read from termfd: read(): " << strerror(errno) << endl;
        @}
        cout << "# " << flush;
    @}
    cout << "\nstdin closed. Bye" << endl;
@}
@end example


@b{Note}


@example
Linux features nonstandard syscall signalfd() which creates a file descriptor for accepting signals. This syscall inspired the name of class template signalfd.
@end example

@node Header <unixsignal/signal_handler.hpp>
@chapter Header <unixsignal/signal_handler.hpp>

@b{Synopsis}

@example
namespace unixsignal @{

template <int Signo>
class signal_handler
@{
public:
    explicit signal_handler(boost::asio::io_service& ios);

    template <typename Handler>
    void async_wait(Handler h);
@};
@}
@end example

@b{Description}

@example
Class template signal_handler extends boost::asio with the ability to invoke a handler whenever a unix signal arrives.
Users can create an object of signal_handler and use async_wait() along with boost::asio::io_service event processing to asynchronously wait for a signal.
After the associated signal arrives the handler supplied to async_wait() will be invoked.

signal_handler is neither copyable nor assignable.
@end example


explicit signal_handler(boost::asio::io_service& ios)

@example
Effects: Creates instances of signalfd and boost::asio::posix::stream_descriptor. All effects of the constructor of signalfd.
Postconditions: this->async_wait() initiates an asynchronous wait for the signal.
Throws: boost::system_error if the constructor of signalfd fails.
@end example

~signal_handler()

@example
Effects: signal_handler doesn't have an explicit desctructor.
         However, when an object of signal_handler is destroyed an object of signalfd is also destroyed and so, destruction of signal_handler has all effects of destruction of signalfd.
Postconditions: All postconditions of signalfd.
Throws: Does not throw.
@end example

template <typename Handler>
void async_wait(Handler h);

@example
Effects: Initiates an asynchronous wait against the signal and immediately returns.
         For each call to async_wait(), the supplied handler will be called exactly once after the associated signal arrived.
         Parameter handler has to be of the following signature void handler(const boost::system::error_code& error);
         The handler has to be copyable. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io_service::post().
Postconditions: A subsequent arrival of the associated signal will cause one invocation of the provided handler.
Throws: Anything that the underlying boost::asio::async_read() call can throw. Also, anything that the handler copy constructor can throw.
@end example


@b{Example}

@example
#include <iostream>
#include <iomanip>
#include <string>
#include <boost/bind.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/posix/stream_descriptor.hpp>
#include <unixsignal/signal_handler.hpp>

using std::cout;
using std::cin;
using std::endl;
using std::cerr;
using std::flush;

namespace ba = boost::asio;
namespace bap = boost::asio::posix;

void on_signal(boost::system::error_code const& error, int signo, int* invoked)
@{
    if (!error)
        cout << "signal #" << signo << " received" << endl << "# " << flush;
    *invoked = 1;
@}

void on_stdin(boost::system::error_code const& error, char const* buf, std::size_t buflen, int* running)
@{
    if (!error)
    @{
        assert(buflen >= 1 && "Incorrect usage of boost::asio");
        cout << "activity on stdin: " << std::string(buf, buflen - 1) << endl << "# " << flush;
    @}
    else
    @{
        if (ba::error::eof == error)
        @{
            cout << "stdin closed." << flush;
            *running = 0;
        @}
	else
            cout << "stdin error: " << error << endl;
   @}
@}

int main(int, char const* [])
@{
    ba::io_service ios;

    unixsignal::signal_handler<SIGINT> sigint(ios);
    unixsignal::signal_handler<SIGTERM> sigterm(ios);

    bap::stream_descriptor std_in(ios, STDIN_FILENO);

    cout << "Type to watch stdin activity. Send signals to watch the program react. Use ^D to exit" << endl << "# " << flush;

    int running = 1;
    int sigint_restart_wait = 1;
    int sigterm_restart_wait = 1;
    while (running)
    @{
        ios.reset();

        if (sigint_restart_wait)
        @{
            sigint_restart_wait = 0;
            sigint.async_wait(boost::bind(on_signal, _1, SIGINT, &sigint_restart_wait));
        @}
        if (sigterm_restart_wait)
        @{
            sigterm_restart_wait = 0;
            sigterm.async_wait(boost::bind(on_signal, _1, SIGTERM, &sigterm_restart_wait));
        @}

        char buf[1024];
        std_in.async_read_some(ba::buffer(buf, sizeof buf), boost::bind(on_stdin, _1, buf, _2, &running));

        ios.poll();
    @}
    cout << " Bye" << endl;
@}
@end example


@bye

