\input texinfo
@setfilename unixsignal.info
@include version.texi
@settitle libunixsignal @value{VERSION} manual

@copying
Copyright @copyright{} 2009 Dmitry Goncharov.
Distributed under the BSD license.
@end copying

@dircategory libraries
@direntry
* libunixsignal: libunixsignal.
@end direntry

@titlepage
@title libunixsignal manual
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Dmitry Goncharov (@email{dgoncharov@@users.sf.net})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top libunixsignal manual

This manual is for libunixsignal (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Introduction::
* Header <unixsignal/signalfd.hpp>::
* Header <unixsignal/signal_handler.hpp>::
* Acknowledgments::
@end menu


@node Introduction
@chapter Introduction
libunixsignal lets you associate a unix signal with a file descriptor
and have the file descriptor ready for reading whenever the associated unix signal arrives.
This lets multiplex unix signals just like file descriptors.
This library also extends boost::asio with the ability to invoke a handler whenever a unix signal arrives.

Motivation for this library was the need to pass user data to a signal handler.
Another motivating desire was the need to invoke syscalls which are not async-signal-safe from a signal handler. 

The library consists of two header files unixsignal/signalfd.hpp and unixsignal/signal_handler.hpp.

The library can be used to handle asynchronous unix signals such as SIGINT or SIGHUP.
It is not recommended to use the library to handle synchronous unix signals such as SIGFPE, SIGILL, SIGSEGV, or SIGBUS unless the signal was generated by the kill() function, the sigqueue() function, or the raise() function.

@node Header <unixsignal/signalfd.hpp>
@chapter Header <unixsignal/signalfd.hpp>

@b{Synopsis}


@example
namespace unixsignal @{

template <
    int S1, int S2 = 0, int S3 = 0, int S4 = 0, int S5 = 0,
    int S6 = 0, int S7 = 0, int S8 = 0, int S9 = 0, int S10 = 0,
    int S11 = 0, int S12 = 0, int S13 = 0, int S14 = 0, int S15 = 0,
    int S16 = 0, int S17 = 0, int S18 = 0, int S19 = 0, int S20 = 0,
    int S21 = 0, int S22 = 0, int S23 = 0, int S24 = 0, int S25 = 0,
    int S26 = 0, int S27 = 0, int S28 = 0, int S29 = 0, int S30 = 0>
class signalfd
@{
public:
    signalfd();
    ~signalfd();

    int fd() const;
@};

@}
@end example

@*
@b{Description}


Class template signalfd creates a file descriptor and associates it with one or more signals specified by the template parameters S1, S2,... S30.
At least one signal has to be specified. Up to 30 signals can be associated with one file descriptor.

This file descriptor becomes ready for reading each time one of the associated signals arrives.
Select/poll multiplexing can be used to wait for this file descriptor to become reading for reading.
After the file desriptor became ready for reading read() returns an instance of struct siginfo_t in the supplied buffer.
The buffer must be at least sizeof(siginfo_t) bytes long. The struct siginfo_t describes the arrived signal.
The descriptor remains in the ready-for-reading state until sizeof(siginfo_t) bytes get read.

This file descriptor cannot be passed to write().

Each instance of signalfd allocates a buffer. Therefore an application can end up with lots of buffers if it creates lots of signalfd. If an application creates one singalfd and associates it with all interesting signals only one buffer is allocated.

signalfd keeps every struct siginfo_t in the internal buffer until it is read. Therefore, there can be more than one instance of siginfo_t waiting for being read. Since the size of the buffer is limited if signals arrive more often than structs siginfo_t are read from the file descriptor the new signals get discarded as soon as the buffer is full.
Structs siginfo_t are read from the buffer in the FIFO order.
The size of the buffer depends on the kernel and is usually a few KB.

signalfd is neither copyable nor assignable.

signalfd uses the following syscalls pipe(), sigaction(), close(), write() and is portable as long as these syscalls are portable.

@*
signalfd()

@itemize @w{}
@item
Effects: Creates an instance of signalfd. Sets the disposition of the specified signals to a pointer to a function.
Creates a file descritor and assiciated it with the specified signal.

@item
Postconditions: this->fd() return the file descriptor associated with the signal.

@item
Throws: boost::system_error if one of the syscalls fails. If an exception is thrown the signals disposition remains intact.
@end itemize

@*
~signalfd()

@itemize @w{}
@item
Effects: Restores the original signals disposition. Closes the file descriptor.

@item
Postconditions: The original signals disposition is restored.

@item
Throws: Will not throw.
@end itemize

@*
int fd() const

@itemize @w{}
@item
Returns: The file descriptor associated with the signals.

@item
Throws: Will not throw.
@end itemize

@*
@b{Example}


@example
#include <unixsignal/signalfd.hpp>
#include <sys/select.h>
#include <signal.h>
#include <cstdio>
#include <cstdlib>
#include <cstddef>
#include <cerrno>
#include <cstring>
#include <iostream>
#include <iomanip>
#include <string>

using std::cout;
using std::cin;
using std::endl;
using std::cerr;
using std::flush;

void readsig(int fd)
@{
    cout << "received signal";
    siginfo_t siginfo;
    ssize_t const s = read(fd, &siginfo, sizeof siginfo);
    if (s < 0)
        cerr << "Cannot read: read(): " << std::strerror(errno) << endl;
    else if (static_cast<std::size_t>(s) < sizeof siginfo)
        cerr
	    << "\nCannot read siginfo_t. Read " << s << " bytes"
	    << endl;
    else
        cout << " #" << siginfo.si_signo << endl;
@}

int main(int, char const* [])
@{
    unixsignal::signalfd<SIGINT, SIGTERM> sigint;
    int const intfd = sigint.fd();

    unixsignal::signalfd<SIGHUP, SIGUSR1, SIGUSR2> sighup;
    int const hupfd = sighup.fd();

    cout << "Type to watch stdin activity\n"
         << "Send the following signals to watch the program react #"
         << SIGINT << ", #" << SIGTERM
         << ", #" << SIGHUP << ", #" << SIGUSR1 << ", #" << SIGUSR2
         << "\nUse ^D to exit"
         << endl << "# " << flush;
    while (std::cin)
    @{
        fd_set rfds;
        FD_ZERO(&rfds);
        FD_SET(STDIN_FILENO, &rfds);
        FD_SET(intfd, &rfds);
        FD_SET(hupfd, &rfds);

        int const s = select(std::max(intfd, hupfd) + 1, &rfds, 0, 0, 0);
        if (s < 0)
        @{
            if (EINTR != errno)
                cerr << "select(): " << std::strerror(errno) << endl;
            continue;
        @}
        if (FD_ISSET(0, &rfds))
        @{
            std::string s;
            std::getline(cin, s);
            cout << "activity on stdin: " << s << endl;
        @}
        else if (FD_ISSET(intfd, &rfds))
            readsig(intfd);
        else if (FD_ISSET(hupfd, &rfds))
            readsig(hupfd);
        cout << "# " << flush;
    @}
    cout << "\nstdin closed. Bye" << endl;
@}
@end example


@b{Note}


Linux features nonstandard syscall signalfd() which creates a file descriptor for accepting signals. This syscall inspired the name of class template signalfd.

@node Header <unixsignal/signal_handler.hpp>
@chapter Header <unixsignal/signal_handler.hpp>

@b{Synopsis}

@example
namespace unixsignal @{

template <
    int S1, int S2 = 0, int S3 = 0, int S4 = 0, int S5 = 0,
    int S6 = 0, int S7 = 0, int S8 = 0, int S9 = 0, int S10 = 0,
    int S11 = 0, int S12 = 0, int S13 = 0, int S14 = 0, int S15 = 0,
    int S16 = 0, int S17 = 0, int S18 = 0, int S19 = 0, int S20 = 0,
    int S21 = 0, int S22 = 0, int S23 = 0, int S24 = 0, int S25 = 0,
    int S26 = 0, int S27 = 0, int S28 = 0, int S29 = 0, int S30 = 0>
class signal_handler
@{
public:
    explicit signal_handler(boost::asio::io_service& ios);

    template <typename Handler>
    void async_wait(Handler h);
@};
@}
@end example

@*
@b{Description}

Class template signal_handler extends boost::asio with the ability to invoke a handler whenever a unix signal arrives.

An instance of signal_handler can be associated with one or more signals specified by the template parameters S1, S2,... S30.
At least one signal has to be specified. Up to 30 signals can be associated with one signal_handler.
async_wait() along with boost::asio::io_service event processing can be used to asynchronously wait for the associated signals.
After one of the associated signals arrives the handler supplied to async_wait() will be invoked.
An instance of siginfo_t which describes the arrived signal will be passed to the handler.

signal_handler is neither copyable nor assignable.

@*
explicit signal_handler(boost::asio::io_service& ios)

@itemize @w{}
@item
Effects: Creates instances of signalfd and boost::asio::posix::stream_descriptor. All the effects of signalfd constructor.

@item
Postconditions: this->async_wait() initiates an asynchronous wait for the signal.

@item
Throws: Anything that signalfd constructor can throw.
@end itemize

@*
~signal_handler()

@itemize @w{}
@item
Effects: signal_handler doesn't have an explicit desctructor.
However, when an object of signal_handler is destroyed an object of signalfd is also destroyed and so, destruction of signal_handler has all the effects of destruction of signalfd.

@item
Postconditions: All the postconditions of signalfd.

@item
Throws: Will not throw.
@end itemize

@*
template <typename Handler>
void async_wait(Handler h);

@itemize @w{}
@item
Effects: Initiates an asynchronous wait against the associated signals and immediately returns.
For each call to async_wait(), the supplied handler will be called exactly once after one of the associated signals arrives.
Parameter handler has to be of the following signature void handler(const boost::system::error_code& error, siginfo_t const&);
The handler has to be copyable.
Invocation of the handler will be performed in a manner equivalent to using boost::asio::io_service::post().

@item
Postconditions: A subsequent arrival of one of the associated signals will cause one invocation of the provided handler.

@item
Throws: Anything that the underlying boost::asio::async_read() call can throw. Also, anything that the handler copy constructor can throw.
@end itemize

@*
@b{Example}

@example
#include <unixsignal/signal_handler.hpp>
#include <unistd.h>
#include <cstddef>
#include <cassert>
#include <iostream>
#include <iomanip>
#include <string>
#include <boost/bind.hpp>
#include <boost/system/error_code.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/posix/stream_descriptor.hpp>
#include <boost/asio/buffer.hpp>
#include <boost/asio/error.hpp>

using std::cout;
using std::cin;
using std::endl;
using std::cerr;
using std::flush;

namespace ba = boost::asio;
namespace bap = boost::asio::posix;
namespace bs = boost::system;

void on_signal(bs::error_code const& err, siginfo_t const& siginfo, int* invoked)
@{
    if (!err)
        cout
            << "signal #" << siginfo.si_signo << " received"
            << endl << "# " << flush;
    *invoked = 1;
@}

void on_stdin(
    bs::error_code const& err, char const* buf, std::size_t buflen, int* running)
@{
    if (!err)
    @{
        assert(buflen >= 1 && "Incorrect usage of boost::asio");
        cout 
            << "activity on stdin: " << std::string(buf, buflen - 1)
            << endl << "# " << flush;
    @}
    else
    @{
        if (ba::error::eof == err)
        @{
            cout << "stdin closed." << flush;
            *running = 0;
        @}
        else
            cout << "stdin error: " << err << endl;
    @}
@}

int main(int, char const* [])
@{
    ba::io_service ios;

    unixsignal::signal_handler<SIGINT, SIGTERM> sigint(ios);
    unixsignal::signal_handler<SIGHUP, SIGUSR1, SIGUSR2> sighup(ios);

    bap::stream_descriptor std_in(ios, STDIN_FILENO);

    cout << "Type to watch stdin activity\n"
         << "Send the following signals to watch the program react #"
         << SIGINT << ", #" << SIGTERM << ", #"
         << SIGHUP << ", #" << SIGUSR1 << ", #" << SIGUSR2
         << "\nUse ^D to exit"
         << endl << "# " << flush;

    int running = 1;
    int intf = 1;
    int hupf = 1;
    while (running)
    @{
        ios.reset();

        if (intf)
        @{
            intf = 0;
            sigint.async_wait(boost::bind(on_signal, _1, _2, &intf));
        @}
        if (hupf)
        @{
            hupf = 0;
            sighup.async_wait(boost::bind(on_signal, _1, _2, &hupf));
        @}

        char buf[1024];
        std_in.async_read_some(
            ba::buffer(buf, sizeof buf),
            boost::bind(on_stdin, _1, buf, _2, &running));

        ios.run_one();
    @}
    cout << " Bye" << endl;
@}
@end example

@node Acknowledgments
@chapter Acknowledgments

Thanks to Amy Krishnevsky for proofreading.

@bye

